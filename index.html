<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- CSP: 允许 CDN、摄像头、WebGL 和内联脚本 -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https:;
        script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.tailwindcss.com https://unpkg.com https://cdn.jsdelivr.net https://esm.sh https://storage.googleapis.com;
        style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
        font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com;
        img-src 'self' data: blob: https:;
        media-src 'self' blob: mediastream:;
        connect-src 'self' https: wasm-unsafe-eval blob: data:;
        worker-src 'self' blob:;
    ">
    <title>Cyberpunk Particle Tree V1.0</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Tailwind CSS (CDN for styling convenience matching original) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Import Map for Three.js and MediaPipe -->
    <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
    "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/+esm",
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "three/": "https://esm.sh/three@^0.182.0/"
  }
}
</script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Share Tech Mono', monospace;
            user-select: none;
        }
        canvas {
            display: block;
        }

        /* HUD Effects */
        .text-glow { text-shadow: 0 0 10px rgba(0, 255, 255, 0.7); }
        .box-glow { box-shadow: 0 0 20px rgba(0, 255, 255, 0.1), inset 0 0 20px rgba(0, 255, 255, 0.05); }
        
        .scan-line {
            position: absolute;
            width: 100%;
            height: 5px;
            background: rgba(0, 255, 255, 0.3);
            animation: scan 3s linear infinite;
            opacity: 0.2;
            pointer-events: none;
            z-index: 10;
        }
        @keyframes scan { from { top: -10px; } to { top: 100vh; } }

        /* HUD Transitions */
        .hud-bar-inner { transition: width 0.3s ease, background-color 0.3s ease; }
        .hud-text-transition { transition: color 0.3s ease; }

        #error-modal {
            display: none;
        }

        /* Loading Overlay */
        #loading-overlay {
            position: fixed;
            inset: 0;
            z-index: 100;
            background: linear-gradient(135deg, #000508 0%, #001015 50%, #000508 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }
        #loading-overlay.hidden {
            opacity: 0;
            visibility: hidden;
        }
        .loading-logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            font-weight: bold;
            color: white;
            letter-spacing: 0.2em;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8), 0 0 40px rgba(0, 255, 255, 0.4);
            animation: pulse-glow 2s ease-in-out infinite;
        }
        .loading-logo span {
            color: #22d3ee;
        }
        @keyframes pulse-glow {
            0%, 100% { text-shadow: 0 0 20px rgba(0, 255, 255, 0.8), 0 0 40px rgba(0, 255, 255, 0.4); }
            50% { text-shadow: 0 0 30px rgba(0, 255, 255, 1), 0 0 60px rgba(0, 255, 255, 0.6), 0 0 80px rgba(0, 255, 255, 0.3); }
        }
        .loading-container {
            margin-top: 3rem;
            width: 320px;
        }
        .loading-status {
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.75rem;
            color: #9ca3af;
            text-align: center;
            margin-bottom: 1rem;
            letter-spacing: 0.1em;
        }
        .loading-status .highlight {
            color: #22d3ee;
        }
        .loading-bar-bg {
            width: 100%;
            height: 4px;
            background: rgba(34, 211, 238, 0.1);
            border: 1px solid rgba(34, 211, 238, 0.3);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }
        .loading-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #22d3ee, #a855f7, #22d3ee);
            background-size: 200% 100%;
            animation: gradient-shift 2s linear infinite;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.8);
        }
        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }
        .loading-bar-glow {
            position: absolute;
            top: -2px;
            bottom: -2px;
            left: 0;
            width: 60px;
            background: linear-gradient(90deg, transparent, rgba(34, 211, 238, 0.6), transparent);
            animation: glow-sweep 1.5s ease-in-out infinite;
        }
        @keyframes glow-sweep {
            0% { left: -60px; }
            100% { left: 100%; }
        }
        .loading-steps {
            margin-top: 1.5rem;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.65rem;
            color: #4b5563;
        }
        .loading-step {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            transition: color 0.3s ease;
        }
        .loading-step.active {
            color: #22d3ee;
        }
        .loading-step.completed {
            color: #10b981;
        }
        .loading-step .icon {
            width: 12px;
            text-align: center;
        }
        .loading-step.active .icon::before {
            content: '▶';
            animation: blink 0.5s infinite;
        }
        .loading-step.completed .icon::before {
            content: '✓';
        }
        .loading-step.pending .icon::before {
            content: '○';
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .loading-corner {
            position: absolute;
            width: 20px;
            height: 20px;
            border-color: rgba(34, 211, 238, 0.5);
        }
        .loading-corner.tl { top: 20%; left: 20%; border-top: 2px solid; border-left: 2px solid; }
        .loading-corner.tr { top: 20%; right: 20%; border-top: 2px solid; border-right: 2px solid; }
        .loading-corner.bl { bottom: 20%; left: 20%; border-bottom: 2px solid; border-left: 2px solid; }
        .loading-corner.br { bottom: 20%; right: 20%; border-bottom: 2px solid; border-right: 2px solid; }
    </style>
</head>
<body>

    <!-- 0. Loading Overlay -->
    <div id="loading-overlay">
        <div class="loading-corner tl"></div>
        <div class="loading-corner tr"></div>
        <div class="loading-corner bl"></div>
        <div class="loading-corner br"></div>
        
        <div class="loading-logo">NEBULA<span>TREE</span></div>
        
        <div class="loading-container">
            <div id="loading-status" class="loading-status">
                <span class="highlight">[BOOT]</span> INITIALIZING SYSTEMS...
            </div>
            <div class="loading-bar-bg">
                <div id="loading-bar" class="loading-bar-fill"></div>
                <div class="loading-bar-glow"></div>
            </div>
            
            <div class="loading-steps">
                <div id="step-1" class="loading-step active">
                    <span class="icon"></span>
                    <span>LOADING VISION MODULE</span>
                </div>
                <div id="step-2" class="loading-step pending">
                    <span class="icon"></span>
                    <span>REQUESTING CAMERA ACCESS</span>
                </div>
                <div id="step-3" class="loading-step pending">
                    <span class="icon"></span>
                    <span>INITIALIZING 3D ENGINE</span>
                </div>
                <div id="step-4" class="loading-step pending">
                    <span class="icon"></span>
                    <span>SYSTEM READY</span>
                </div>
            </div>
        </div>
    </div>

    <!-- 1. Main 3D Scene Container -->
    <div id="scene-container" class="absolute inset-0 z-0 bg-black"></div>

    <!-- 2. HUD Overlay -->
    <div id="hud-container" class="absolute inset-0 z-20 pointer-events-none overflow-hidden">
        <div class="scan-line"></div>

        <!-- Header -->
        <div class="absolute top-0 left-0 w-full p-8 flex justify-between items-start bg-gradient-to-b from-black/80 to-transparent">
            <div>
                <h1 class="text-5xl font-['Orbitron'] font-bold text-white tracking-[0.2em] text-glow">
                    NEBULA<span class="text-cyan-400">TREE</span>
                </h1>
                <div class="flex items-center gap-4 mt-2">
                    <div class="px-2 py-0.5 bg-cyan-900/40 border border-cyan-500/30 text-cyan-300 text-xs font-['Share_Tech_Mono']">
                        V1.0 SYNERGY
                    </div>
                    <div id="system-status" class="text-xs text-gray-400 font-['Share_Tech_Mono']">
                        SYSTEM INITIALIZING...
                    </div>
                </div>
            </div>
            <div class="text-right">
                <div id="fps-counter" class="font-['Share_Tech_Mono'] text-4xl text-cyan-400 font-bold opacity-80">0</div>
                <div class="text-[10px] text-cyan-600 tracking-widest uppercase">Frames Per Second</div>
            </div>
        </div>

        <!-- Interaction Hint -->
        <div id="interaction-hint" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center transition-opacity duration-500">
            <div class="w-64 h-64 border border-cyan-500/20 rounded-full flex items-center justify-center animate-pulse">
                <div class="w-56 h-56 border border-cyan-500/10 rounded-full"></div>
            </div>
            <div class="mt-4 text-cyan-300 font-['Share_Tech_Mono'] bg-black/50 px-4 py-1 rounded border border-cyan-500/30">
                RAISE HANDS TO ENGAGE
            </div>
        </div>

        <!-- Right Side Data Panel -->
        <div class="absolute top-1/2 right-6 -translate-y-1/2 flex flex-col gap-4 w-72">
            <!-- Mode Status -->
            <div id="mode-panel" class="p-6 border-l-4 backdrop-blur-md transition-all duration-300 bg-gray-900/40 border-gray-500">
                <div class="text-[10px] text-gray-400 font-['Share_Tech_Mono'] mb-1">SYNERGY PROTOCOL</div>
                <div id="synergy-mode-text" class="text-xl font-['Orbitron'] font-bold tracking-wider text-pink-400 hud-text-transition">
                    STANDBY
                </div>
                <div class="h-1 w-full bg-gray-800 mt-3 overflow-hidden">
                    <div id="strength-bar" class="hud-bar-inner h-full bg-pink-500" style="width: 0%"></div>
                </div>
            </div>

            <!-- Telemetry -->
            <div class="bg-black/40 border border-gray-700/50 p-4 font-['Share_Tech_Mono'] text-xs text-gray-300 box-glow">
                <div class="flex justify-between mb-2 border-b border-gray-800 pb-1">
                    <span>HANDS DETECTED</span>
                    <span id="hand-count-display" class="text-cyan-400">0</span>
                </div>
                <div class="flex justify-between mb-2 border-b border-gray-800 pb-1">
                    <span>SCALE FACTOR</span>
                    <span id="scale-display" class="text-cyan-400">1.00x</span>
                </div>
                <div class="flex justify-between">
                    <span>TURBULENCE</span>
                    <span id="turbulence-display" class="text-yellow-400">100%</span>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="absolute bottom-6 left-1/2 -translate-x-1/2 text-center pointer-events-none">
            <div class="text-[10px] font-['Share_Tech_Mono'] text-white/40 tracking-widest uppercase">
                <div>Created by Katelya</div>
                <div class="text-[9px] mt-1 text-white/20">DecohererK</div>
            </div>
        </div>
    </div>

    <!-- 3. Error Modal -->
    <div id="error-modal" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-red-900/90 border border-red-500 p-8 rounded text-white font-mono text-center z-50">
        <div class="text-2xl font-bold mb-4 font-['Orbitron'] text-red-500">SYSTEM FAILURE</div>
        <div id="error-message" class="text-sm mb-6"></div>
        <button onclick="window.location.reload()" class="px-6 py-2 bg-red-600 font-bold uppercase hover:bg-red-500">Reboot</button>
    </div>

    <!-- 4. AR Vision Feed & Tech Glove Container -->
    <div class="absolute bottom-6 left-6 z-30 flex flex-col items-start pointer-events-none">
        <div class="relative border-2 border-cyan-500/50 bg-black/80 backdrop-blur-md p-1 shadow-[0_0_20px_rgba(0,255,255,0.4)] rounded-tl-2xl rounded-br-2xl overflow-hidden">
            <div id="ar-header" class="absolute top-0 left-0 bg-cyan-500/20 px-2 py-1 text-[10px] text-cyan-200 font-['Share_Tech_Mono'] z-20">
                V1.0_DUAL_LINK :: 0 SIGNAL(S)
            </div>
            
            <!-- Webcam Video (Mirrored & Filtered) -->
            <video id="webcam-video" 
                width="320" height="240" 
                autoplay playsinline muted 
                class="transform scale-x-[-1] opacity-70 filter grayscale contrast-125 sepia-[0.3]"
                style="width: 320px; height: 240px; object-fit: contain;">
            </video>

            <!-- Orthographic Overlay Canvas Container -->
            <div id="glove-container" class="absolute inset-0 z-10" style="width: 320px; height: 240px;"></div>

            <!-- Decorations -->
            <div class="absolute inset-0 bg-[linear-gradient(transparent_50%,rgba(0,255,255,0.05)_50%)] bg-[length:100%_4px] pointer-events-none z-20"></div>
            <div class="absolute top-0 right-0 w-8 h-8 border-t-2 border-r-2 border-cyan-400 z-20"></div>
            <div class="absolute bottom-0 left-0 w-8 h-8 border-b-2 border-l-2 border-cyan-400 z-20"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- CONSTANTS ---
        const PARTICLE_COUNT = 15000;
        const TREE_HEIGHT = 20;
        const TREE_RADIUS = 8;
        const VIDEO_WIDTH = 320;
        const VIDEO_HEIGHT = 240;
        const MAX_HANDS = 2;

        // Physics
        const SPRING_STRENGTH = 0.02;
        const DAMPING = 0.95;

        // Hand Connections (Skeleton)
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4], // Thumb
            [0, 5], [5, 6], [6, 7], [7, 8], // Index
            [0, 9], [9, 10], [10, 11], [11, 12], // Middle
            [0, 13], [13, 14], [14, 15], [15, 16], // Ring
            [0, 17], [17, 18], [18, 19], [19, 20] // Pinky
        ];

        // --- GLOBAL STATE ---
        const state = {
            handData: {
                x: 0.5,
                y: 0.5,
                rotation: 0,
                gestureStrength: 0,
                targetScale: 1.0,
                spinSpeed: 1.0,
                turbulence: 1.0,
                handCount: 0,
                synergyMode: 'IDLE', // 'STANDARD' | 'HYPER_COMPRESSION' | 'BALANCED_EXPANSION' | 'TOTAL_CHAOS'
                isPresent: false,
            },
            fps: 0,
            loading: true
        };

        // --- 1. VISION SERVICE ---
        class VisionService {
            constructor() {
                this.handLandmarker = null;
                this.video = null;
                this.lastVideoTime = -1;
            }

            async initialize() {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm"
                );
                this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: MAX_HANDS // Dual Hand Support
                });
            }

            attachVideo(videoElement) {
                this.video = videoElement;
            }

            detect(callback) {
                if (!this.handLandmarker || !this.video) return;
                if (this.video.readyState < 2) return;

                const nowInMs = Date.now();
                if (this.video.currentTime !== this.lastVideoTime) {
                    this.lastVideoTime = this.video.currentTime;
                    const results = this.handLandmarker.detectForVideo(this.video, nowInMs);
                    callback(results);
                }
            }
        }
        const visionService = new VisionService();

        // --- 2. MAIN 3D SCENE (PARTICLES) ---
        function initMainScene() {
            const container = document.getElementById('scene-container');
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000508, 0.04);

            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 12, 35);
            camera.lookAt(0, 10, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // Post Processing
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.8, 0.4, 0.2
            );
            const composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            // Particle System
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const originalPositions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const velocities = new Float32Array(PARTICLE_COUNT * 3); 
            const randomness = new Float32Array(PARTICLE_COUNT * 3);

            const colorOuter = new THREE.Color(0x00FFFF); 
            const colorInner = new THREE.Color(0xFF00AA); 
            const tempColor = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const ratio = i / PARTICLE_COUNT; 
                
                const y = ratio * TREE_HEIGHT;
                const r = (1 - ratio) * TREE_RADIUS;
                const angle = ratio * Math.PI * 30 + (Math.random() * 0.5); 

                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;

                originalPositions[i3] = x + (Math.random() - 0.5);
                originalPositions[i3+1] = y + (Math.random() - 0.5);
                originalPositions[i3+2] = z + (Math.random() - 0.5);

                positions[i3] = (Math.random() - 0.5) * 60;
                positions[i3+1] = (Math.random() - 0.5) * 60 + 10;
                positions[i3+2] = (Math.random() - 0.5) * 60;

                velocities[i3] = 0; velocities[i3+1] = 0; velocities[i3+2] = 0;
                randomness[i3] = Math.random(); randomness[i3+1] = Math.random(); randomness[i3+2] = Math.random();

                tempColor.lerpColors(colorInner, colorOuter, Math.random());
                colors[i3] = tempColor.r; colors[i3+1] = tempColor.g; colors[i3+2] = tempColor.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8,
            });

            const particles = new THREE.Points(geometry, material);
            const treeGroup = new THREE.Group();
            treeGroup.add(particles);
            scene.add(treeGroup);

            // Floor
            const gridHelper = new THREE.GridHelper(80, 40, 0x004444, 0x111111);
            gridHelper.position.y = -2;
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.2;
            scene.add(gridHelper);

            // Physics Variables
            let currentScale = 1.0;
            let currentTurbulence = 1.0;
            const clock = new THREE.Clock();

            function animate() {
                requestAnimationFrame(animate);
                
                const delta = clock.getDelta();
                const time = clock.getElapsedTime();
                state.fps = Math.round(1 / delta);

                const hand = state.handData;
                const positionsArr = geometry.attributes.position.array;
                
                const targetStrength = hand.isPresent ? hand.gestureStrength : 0; 
                
                // Interpolate global physics parameters
                currentScale += (hand.targetScale - currentScale) * 0.05;
                currentTurbulence += (hand.turbulence - currentTurbulence) * 0.05;

                if (hand.isPresent) {
                    const targetX = (hand.x - 0.5) * 10;
                    const targetY = 12 + (hand.y - 0.5) * 5;
                    camera.position.x += (targetX - camera.position.x) * 0.05;
                    camera.position.y += (targetY - camera.position.y) * 0.05;

                    const targetRot = hand.rotation * 2.0; 
                    treeGroup.rotation.y += ((targetRot - treeGroup.rotation.y) * 0.1) + (0.01 * hand.spinSpeed);
                } else {
                    treeGroup.rotation.y += 0.005;
                    currentScale += (1.0 - currentScale) * 0.02;
                }

                // --- Physics Loop ---
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const i3 = i * 3;
                    
                    const px = positionsArr[i3], py = positionsArr[i3+1], pz = positionsArr[i3+2];
                    let vx = velocities[i3], vy = velocities[i3+1], vz = velocities[i3+2];

                    const ox = originalPositions[i3], oy = originalPositions[i3+1], oz = originalPositions[i3+2];

                    // Scale Ordered Target
                    const tox = ox * currentScale;
                    const toy = oy * currentScale;
                    const toz = oz * currentScale;

                    // Chaos Target
                    const r = randomness[i3] * 10 + 15;
                    const theta = time * 0.2 + randomness[i3+1] * 10;
                    const cx = Math.cos(theta) * r;
                    const cy = oy + Math.sin(time + randomness[i3]) * 5;
                    const cz = Math.sin(theta) * r;

                    // Blend Targets
                    const tx = cx * (1 - targetStrength) + tox * targetStrength;
                    const ty = cy * (1 - targetStrength) + toy * targetStrength;
                    const tz = cz * (1 - targetStrength) + toz * targetStrength;

                    // Forces
                    vx += (tx - px) * SPRING_STRENGTH;
                    vy += (ty - py) * SPRING_STRENGTH;
                    vz += (tz - pz) * SPRING_STRENGTH;

                    // Turbulence
                    if (targetStrength < 0.8) {
                        const noiseAmp = 0.05 * (1 - targetStrength) * currentTurbulence;
                        vx += (Math.random() - 0.5) * noiseAmp;
                        vy += (Math.random() - 0.5) * noiseAmp;
                        vz += (Math.random() - 0.5) * noiseAmp;
                    }

                    // Damping
                    vx *= DAMPING; vy *= DAMPING; vz *= DAMPING;

                    // Update Position
                    positionsArr[i3] = px + vx;
                    positionsArr[i3+1] = py + vy;
                    positionsArr[i3+2] = pz + vz;

                    velocities[i3] = vx; velocities[i3+1] = vy; velocities[i3+2] = vz;
                }

                geometry.attributes.position.needsUpdate = true;
                composer.render();
            }

            animate();

            // Resize Handler
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- 3. AR GLOVE OVERLAY (ORTHOGRAPHIC) ---
        function initARScene() {
            const container = document.getElementById('glove-container');
            const scene = new THREE.Scene();
            
            const camera = new THREE.OrthographicCamera(
                VIDEO_WIDTH / -2, VIDEO_WIDTH / 2, 
                VIDEO_HEIGHT / 2, VIDEO_HEIGHT / -2, 
                0.1, 1000
            );
            camera.position.z = 100;

            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(VIDEO_WIDTH, VIDEO_HEIGHT);
            renderer.setClearColor(0x000000, 0);
            container.appendChild(renderer.domElement);

            // Materials
            const jointGeo = new THREE.OctahedronGeometry(3.5, 0);
            const jointMat = new THREE.MeshBasicMaterial({ 
                color: 0x00FFFF, wireframe: true, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending 
            });

            const boneMat = new THREE.MeshBasicMaterial({ 
                color: 0x0088FF, wireframe: true, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending, depthTest: false 
            });
            const boneGeoTemplate = new THREE.CylinderGeometry(1, 1, 1, 4, 1, true); 
            boneGeoTemplate.rotateX(Math.PI / 2); 
            boneGeoTemplate.rotateZ(Math.PI / 4);

            // Create Hand Meshes Pool
            const handMeshes = [];
            for (let h = 0; h < MAX_HANDS; h++) {
                const joints = [];
                const bones = [];

                for (let i = 0; i < 21; i++) {
                    const mesh = new THREE.Mesh(jointGeo, jointMat);
                    mesh.visible = false;
                    scene.add(mesh);
                    joints.push(mesh);
                }

                HAND_CONNECTIONS.forEach(() => {
                    const bone = new THREE.Mesh(boneGeoTemplate, boneMat);
                    bone.visible = false;
                    scene.add(bone);
                    bones.push(bone);
                });

                handMeshes.push({ joints, bones });
            }

            return { scene, camera, renderer, handMeshes };
        }

        // --- 4. LOGIC & LOOP ---
        function analyzeHand(landmarks) {
            const wrist = landmarks[0];
            const indexMCP = landmarks[5];

            // Rotation
            const dx = indexMCP.x - wrist.x;
            const dy = indexMCP.y - wrist.y;
            const angle = Math.atan2(-dy, dx); 
            const rotation = (angle - Math.PI/2) * -1;

            // Strength
            const tips = [8, 12, 16, 20];
            let avgDist = 0;
            tips.forEach(idx => {
                const tx = landmarks[idx].x - wrist.x;
                const ty = landmarks[idx].y - wrist.y;
                avgDist += Math.sqrt(tx*tx + ty*ty);
            });
            avgDist /= 4;
            let strength = (0.35 - avgDist) / (0.35 - 0.15);
            strength = Math.max(0, Math.min(1, strength));

            return { x: 1 - wrist.x, y: wrist.y, rotation, strength, isFist: strength > 0.6 };
        }

        function updateHUD() {
            // Update FPS
            document.getElementById('fps-counter').innerText = state.fps;

            // Update System Status
            const statusEl = document.getElementById('system-status');
            if (state.loading) {
                statusEl.innerText = "SYSTEM INITIALIZING...";
            } else {
                statusEl.innerText = "SYSTEM ONLINE";
            }

            // Interaction Hint
            const hint = document.getElementById('interaction-hint');
            hint.style.opacity = state.handData.isPresent ? '0' : '1';

            // Mode & Strength
            const modeText = document.getElementById('synergy-mode-text');
            const strengthBar = document.getElementById('strength-bar');
            
            const mode = state.handData.synergyMode;
            modeText.innerText = mode.replace('_', ' ');
            
            // Colors
            modeText.className = "text-xl font-['Orbitron'] font-bold tracking-wider hud-text-transition";
            strengthBar.className = "hud-bar-inner h-full transition-all duration-300";

            if (mode === 'HYPER_COMPRESSION') {
                modeText.classList.add('text-purple-400');
                strengthBar.classList.add('bg-purple-500');
            } else if (mode === 'BALANCED_EXPANSION') {
                modeText.classList.add('text-green-400');
                strengthBar.classList.add('bg-green-500');
            } else if (mode === 'TOTAL_CHAOS') {
                modeText.classList.add('text-red-400');
                strengthBar.classList.add('bg-red-500');
            } else if (state.handData.gestureStrength > 0.5) {
                modeText.classList.add('text-cyan-300');
                strengthBar.classList.add('bg-cyan-400');
            } else {
                modeText.classList.add('text-pink-400');
                strengthBar.classList.add('bg-pink-500');
            }

            strengthBar.style.width = `${state.handData.gestureStrength * 100}%`;

            // Telemetry
            document.getElementById('hand-count-display').innerText = state.handData.handCount;
            document.getElementById('scale-display').innerText = state.handData.targetScale.toFixed(2) + "x";
            document.getElementById('turbulence-display').innerText = (state.handData.turbulence * 100).toFixed(0) + "%";
            document.getElementById('ar-header').innerText = `V1.0_DUAL_LINK :: ${state.handData.handCount} SIGNAL(S)`;
        }

        // --- Loading Progress Controller ---
        function updateLoadingProgress(step, progress, statusText) {
            const loadingBar = document.getElementById('loading-bar');
            const loadingStatus = document.getElementById('loading-status');
            
            loadingBar.style.width = `${progress}%`;
            loadingStatus.innerHTML = statusText;
            
            // Update step indicators
            for (let i = 1; i <= 4; i++) {
                const stepEl = document.getElementById(`step-${i}`);
                stepEl.classList.remove('active', 'completed', 'pending');
                if (i < step) {
                    stepEl.classList.add('completed');
                } else if (i === step) {
                    stepEl.classList.add('active');
                } else {
                    stepEl.classList.add('pending');
                }
            }
        }

        function hideLoadingOverlay() {
            const overlay = document.getElementById('loading-overlay');
            overlay.classList.add('hidden');
        }

        async function startApp() {
            // Init Systems
            try {
                // Step 1: Load Vision Module
                updateLoadingProgress(1, 10, '<span class="highlight">[BOOT]</span> LOADING MEDIAPIPE VISION MODULE...');
                await visionService.initialize();
                updateLoadingProgress(1, 30, '<span class="highlight">[BOOT]</span> VISION MODULE LOADED');
                
                // Step 2: Request Camera
                updateLoadingProgress(2, 40, '<span class="highlight">[CAM]</span> REQUESTING CAMERA ACCESS...');
                const videoEl = document.getElementById('webcam-video');
                
                const constraints = {
                    video: {
                        facingMode: 'user',
                        width: { ideal: VIDEO_WIDTH },
                        height: { ideal: VIDEO_HEIGHT }
                    }
                };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                updateLoadingProgress(2, 55, '<span class="highlight">[CAM]</span> CAMERA ACCESS GRANTED');
                
                videoEl.srcObject = stream;
                await new Promise(resolve => videoEl.onloadedmetadata = resolve);
                updateLoadingProgress(2, 65, '<span class="highlight">[CAM]</span> VIDEO STREAM INITIALIZED');
                await videoEl.play();
                
                visionService.attachVideo(videoEl);
                updateLoadingProgress(2, 75, '<span class="highlight">[CAM]</span> HAND TRACKING LINKED');

                // Step 3: Init 3D Engine
                updateLoadingProgress(3, 80, '<span class="highlight">[3D]</span> INITIALIZING THREE.JS ENGINE...');
                initMainScene();
                updateLoadingProgress(3, 90, '<span class="highlight">[3D]</span> PARTICLE SYSTEM ONLINE');
                const arSystem = initARScene();
                updateLoadingProgress(3, 95, '<span class="highlight">[3D]</span> AR OVERLAY READY');
                
                // Step 4: Complete
                updateLoadingProgress(4, 100, '<span class="highlight">[OK]</span> ALL SYSTEMS OPERATIONAL');
                state.loading = false;
                
                // Hide loading overlay after a short delay
                await new Promise(resolve => setTimeout(resolve, 500));
                hideLoadingOverlay();

                // Game Loop
                const loopClock = new THREE.Clock();
                
                function loop() {
                    const time = loopClock.getElapsedTime();

                    // Vision Detection
                    visionService.detect((result) => {
                        const detectedHands = result.landmarks || [];
                        const count = detectedHands.length;

                        // --- SYNERGY LOGIC (V1.0) ---
                        let newData = {
                            handCount: count,
                            isPresent: count > 0,
                            spinSpeed: 1.0,
                            targetScale: 1.0,
                            turbulence: 1.0
                        };

                        if (count === 0) {
                            newData.synergyMode = 'IDLE';
                            newData.gestureStrength = 0;
                            newData.x = 0.5; newData.y = 0.5; newData.rotation = 0;
                        } else if (count === 1) {
                            const h1 = analyzeHand(detectedHands[0]);
                            newData.x = h1.x; newData.y = h1.y; newData.rotation = h1.rotation;
                            newData.gestureStrength = h1.strength;
                            newData.synergyMode = 'STANDARD';
                        } else {
                            const h1 = analyzeHand(detectedHands[0]);
                            const h2 = analyzeHand(detectedHands[1]);
                            
                            newData.x = (h1.x + h2.x) / 2;
                            newData.y = (h1.y + h2.y) / 2;
                            newData.rotation = (h1.rotation + h2.rotation) / 2;

                            if (h1.isFist && h2.isFist) {
                                newData.synergyMode = 'HYPER_COMPRESSION';
                                newData.gestureStrength = 1.0;
                                newData.targetScale = 0.5;
                                newData.spinSpeed = 4.0;
                            } else if (!h1.isFist && !h2.isFist) {
                                newData.synergyMode = 'TOTAL_CHAOS';
                                newData.gestureStrength = 0.0;
                                newData.targetScale = 1.0;
                                newData.turbulence = 3.0;
                            } else {
                                newData.synergyMode = 'BALANCED_EXPANSION';
                                newData.gestureStrength = 1.0;
                                newData.targetScale = 2.0;
                                newData.spinSpeed = 0.5;
                                newData.turbulence = 0.5;
                            }
                        }

                        // Update State
                        state.handData = { ...state.handData, ...newData };

                        // --- AR RENDER ---
                        const { renderer, scene, camera, handMeshes } = arSystem;
                        
                        for (let i = 0; i < MAX_HANDS; i++) {
                            const meshSet = handMeshes[i];
                            const landmarks = detectedHands[i];

                            if (!landmarks) {
                                meshSet.joints.forEach(m => m.visible = false);
                                meshSet.bones.forEach(m => m.visible = false);
                                continue;
                            }

                            // Joints
                            landmarks.forEach((lm, j) => {
                                const joint = meshSet.joints[j];
                                joint.visible = true;
                                const posX = (1 - lm.x) * VIDEO_WIDTH - VIDEO_WIDTH / 2;
                                const posY = (1 - lm.y) * VIDEO_HEIGHT - VIDEO_HEIGHT / 2;
                                const posZ = lm.z * -100;
                                joint.position.set(posX, posY, posZ);
                                joint.rotation.y = time * 2;
                                joint.rotation.z = Math.sin(time + j) * 0.2;
                            });

                            // Bones
                            HAND_CONNECTIONS.forEach((pair, b) => {
                                const bone = meshSet.bones[b];
                                const startNode = meshSet.joints[pair[0]];
                                const endNode = meshSet.joints[pair[1]];
                                const dist = startNode.position.distanceTo(endNode.position);

                                if (dist > 200 || dist < 1) {
                                    bone.visible = false;
                                } else {
                                    bone.visible = true;
                                    bone.position.lerpVectors(startNode.position, endNode.position, 0.5);
                                    bone.lookAt(endNode.position);
                                    bone.scale.set(1, 1, dist);
                                }
                            });
                        }
                        renderer.render(scene, camera);
                    });

                    updateHUD();
                    requestAnimationFrame(loop);
                }
                loop();

            } catch (err) {
                console.error(err);
                document.getElementById('error-modal').style.display = 'block';
                document.getElementById('error-message').innerText = err.message || "Unknown Initialization Error";
            }
        }

        // Boot
        startApp();

    </script>
</body>
</html>